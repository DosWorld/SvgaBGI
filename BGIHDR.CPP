//=========================================================================\\
//				BGIHDR v1.01				   \\
//	BGI header generator for BGI v2.0 or BGI v3.0 graphics drivers	   \\
//									   \\
//     		 Copyright (c) 1993-94 by Jordan Hargraphix		   \\
//			    All Rights Reserved				   \\
//=========================================================================\\
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include "bgihdr.h"

char *months[] = {"Jan","Feb","Mar","Apr","May","Jun",
		  "Jul","Aug","Sep","Oct","Nov","Dec"};

char BGICopyrightMsg[] = "Copyright (c) 1990-94 by Jordan Hargraphix";

char CopyrightMsg[] =
"\t\t\t      BGIHDR v1.01\n"
"      BGI header generator for BGI v2.0 or BGI v3.0 graphics drivers\n"
"\t\tCopyright (c) 1993-94 by Jordan Hargraphix\n"
"\t\t\t    All Rights Reserved\n"
"============================================================================";

char UsageMsg[] =
"Usage: bgihdr drv_name [ driver[.BIN] driver[.BGI] driver[.MAP] ]\n"
"\tdrv_name   : Driver name\n"
"\tdriver.BIN : Binary object file generated by exe2bin\n"
"\tdriver.BGI : output BGI driver name\n"
"\tdriver.MAP : Map file generated by TLINK (needed for BGIv3.0 header)\n";

//%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@
//
//		Generic BGI Header functions
//
//%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@
bgiHeader::bgiHeader(char *drvName,int codeSz,int ver,int rev,int subrev,
		     int minVer,int minRev)
{
    strcpy(myName,drvName);
    codeSize = codeSz;
    version = ver;
    revision = rev;
    subRev = subrev;
    minVersion = minVer;
    minRevision = minRev;
    driverNum = 0;
}

inline void bgiHeader::writeHeader(FILE *outFile)
{
    putw(HEADER_SIZE,outFile);
    putw(driverNum,outFile);
    putw(codeSize,outFile);
    putc(version,outFile);
    putc(revision,outFile);
    putc(minVersion,outFile);
    putc(minRevision,outFile);
}

inline void bgiHeader::writeDriverName(FILE *outFile)
{
    putc(strlen(myName),outFile);
    fprintf(outFile,myName);
}

//%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@
//
//		BGI Header v2.0 functions
//
//%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@
bgiHeader2::bgiHeader2(char *drvName,int codeSz) 
 : bgiHeader(drvName,codeSz,2,0,subRev2,1,0) { };

// Checks to see if the buffer contains a valid BGI v2.0 object file
int bgiHeader2::isHeaderValid(const byte *bufr)
{
    if ((bufr[0]==0x1E) && (bufr[1]==0x0E) && (bufr[2]==0x1F) &&
	(bufr[3]==0xFC) && (bufr[12]=='C') && (bufr[13]=='B')) return 0;
    return 1;
}

//%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@
//
//		BGI Header v3.0 functions
//
//%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@%@
bgiHeader3::bgiHeader3(char *drvName,unsigned int codeSz,
		       unsigned int dataOffset,unsigned int dataSz)
 : bgiHeader(drvName,codeSz,3,0,subRev3,1,0)
{
    dataOfs = dataOffset;
    dataSize = dataSz;
}

// Checks to see if the buffer contains a valid BGI v3.0 object file
inline int bgiHeader3::isHeaderValid(const byte *bufr)
{
    if ((bufr[0]==0x1E) && (bufr[1]==0x2E) && (bufr[2]==0x8E) &&
	(bufr[3]==0x1E)) return 0;
    return 1;
}

inline void bgiHeader3::writeHeader(FILE *outFile)
{
    bgiHeader::writeHeader(outFile);
    putw(dataOfs,outFile);
    putw(dataSize,outFile);
}

void getFileName(char *fileName,int argc,int argn,char *defL,char *defG,char *ext)
{
    if (argc < argn) strcpy(fileName,defL);
    else strcpy(fileName,defG);
    if (strchr(fileName,'.') == NULL)
	strcat(fileName,ext);
}

int main(int argc,char *argv[])
{
    struct date Date;
    char *bgiBufr,*rs;
    char fileName[32],drvName[16],ver[16];
    FILE *inFile, *outFile;
    int bgiVersion;
    bgiHeader *bgiHdr;
    long cPos;
    unsigned int fileSize;

    printf("%s\n",CopyrightMsg);
    if (argc < 2)
    {
	printf("%s\n",UsageMsg);
	exit(1);
    }

    // Get driver name
    strcpy(drvName,argv[1]);
    if ((rs = strchr(drvName,'.')) != NULL)
      *rs = '\0';
    strupr(drvName);

    // Open driver.BIN input file
    getFileName(fileName,argc,3,drvName,argv[2],".bin");
    inFile = fopen(fileName,"rb");
    if (!inFile) {
	printf("ERROR: Couldn't open source[.BIN] file: %s\n",fileName);
	exit(2);
    }

    // Get the size of the source file
    fileSize = filelength(inFile->fd);
    // Read in the entire source file
    bgiBufr = new char[fileSize];
    fread(bgiBufr,fileSize,1,inFile);
    fclose(inFile);
    // Read the version number from the source file
    bgiVersion = bgiBufr[15];

    // Create the BGI header object
    if (bgiVersion >= 0x3)
    {
	char bufr[80],dSeg[8];
	unsigned int codeSize,dataOfs,dataSize;
	unsigned long dStart;

	codeSize = dataOfs = dataSize = 0;
	// Open the driver.MAP file
	getFileName(fileName,argc,5,drvName,argv[4],".map");
	inFile = fopen(fileName,"r");
	if (!inFile) {
	    printf("ERROR: Couldn't open map file: %s\n",fileName);
	    exit(3);
	}
	while(1)
	{
	    if (fgets(bufr,80,inFile) == NULL) break;
	    if (sscanf(bufr,"%lXH %*s %*s %*s %s",&dStart,&dSeg) <= 0)
		continue;
	    if (stricmp(dSeg,"DATA") == 0) {
		codeSize = (int)dStart;
		dataOfs = (int)dStart;
		dataSize = (int)(fileSize - dStart);
		break;
	    }
	}
	fclose(inFile);
	if ((codeSize == 0) || (dataSize == 0))
	{
	    printf("ERROR: Invalid segment size!\n");
	    exit(4);
	}
	bgiHdr = new bgiHeader3(drvName,codeSize,dataOfs,dataSize);
    }
    else
	bgiHdr = new bgiHeader2(drvName,fileSize);

    // Check to see if input file was valid
    if (bgiHdr->isHeaderValid(bgiBufr))
    {
	printf("Error: Unknown driver type! (%d)\n",bgiVersion);
	exit(5);
    }
    printf("Input file is BGI version %d.0\t",bgiVersion);

    // Open driver.BGI output file
    getFileName(fileName,argc,4,drvName,argv[3],".bgi");
    outFile = fopen(fileName,"wb");
    if (!outFile) {
	printf("ERROR: Couldn't open output[.BGI] file: %s\n",fileName);
	exit(3);
    }

    // Get the version number for the driver
    if (!(inFile = fopen("svga_ver.db","r"))) {
	printf("\nEnter version #: ");
	scanf("%s",ver);
    } else
    {
	char ver_driver[16];

	// Scan SVGA_VER.DB file for current driver version
	while(!feof(inFile)) {
	    if (fscanf(inFile,"%s %s\n",ver_driver,ver) <= 0) {
		printf("\nEnter version #: ");
		scanf("%s",ver);
		break;
	    }
	    if (stricmp(ver_driver,drvName) == 0)
		break;
	}
	fclose(inFile);
    }
    printf("Output file is release version: %s\n",ver);

    // Write header text and copyright message
    getdate(&Date);
    fprintf(outFile,"%s%s BGI Device Driver (%s) %s - %s %.2d, %d\r\n",
	    bgiHdr->header(),drvName,drvName,ver,months[Date.da_mon-1],
	    Date.da_day,Date.da_year);
    fprintf(outFile,"%s\r\n",BGICopyrightMsg);
    putc(0x00,outFile);
    putc(0x1A,outFile);

    // Write header information
    bgiHdr->writeHeader(outFile);
    // pad to 0x80
    for(cPos=ftell(outFile);cPos<0x80;cPos++) putc(0x00,outFile);

    // Write header information, followed by driver name
    bgiHdr->writeHeader(outFile);
    bgiHdr->writeDriverName(outFile);
    // pad to HEADER_SIZE
    for(cPos=ftell(outFile);cPos<HEADER_SIZE;cPos++) putc(0x00,outFile);

    // write rest of data
    fwrite(bgiBufr,fileSize,1,outFile);
    fclose(outFile);
    delete bgiBufr;
    return 0;
}
